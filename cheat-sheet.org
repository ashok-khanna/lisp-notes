#+Date: 10 August 2021

#+Title: Common Lisp Cheat Sheet

Below is a cheat sheet for Common Lisp. Only  a very basic
understanding of Common Lisp is required. Hope you like it!

* Notes on Syntax

In the below below a =*= after a form indicates multiple forms
can be included there (sometimes this is known as an implicit
=PROGN=).

* Hello World

#+begin_src lisp

  (print "Hello, World!")
  
#+end_src


* Defining Global Variables

We can define global variables with =DEFPARAMETER= and 
=DEFVAR=. The former can be called multiple times on a
variable and it will re-assign the variable to the latest
value supplied. The latter will only assign a value if it
is not already bound to the variable.

#+begin_src lisp

  ;; Establish an unbound variable
  
  (defvar *x*)
  
  ;; Assign the value 15 to X
  
  (defparameter *x* 15)
  
  ;; Does nothing as X already bound
  
  (defvar *x* 10)

#+end_src

We can define global constants with =DEFCONSTANT=:

#+begin_src lisp

 (defconstant +my-constant+ 20)

#+end_src


* General Purpose Assignment

=SETF= is LISP's general purpose assignment macro and
can assign a value to a designated /place/ (e.g. a variable,
but also many other types of places). It is a very powerful
"setter" that can assign values to many different bjects. Below
is the form it takes and some examples:

#+begin_src lisp

  ;; Form of SETF Macro:

  (setf place value)

  ;; Set x to 10

  (setf x 10)

  ;; Set x to 1 and y to 2

  (setf x 1 y 2)

  ;; Same as (setf x (+ x 1))

  (incf x)

  ;; Same as (setf x (- x 1))

  (decf x)

  ;; Same as (setf x (+ x 10))
  
  (incf x 10)

#+end_src


* Defining Global Functions

Global functions are defined with =DEFUN= with the below syntax.

#+begin_src lisp

  (defun function-name (parameter*)
    "Optional documentation string."
    body-form*)

#+end_src

Below is example of a function that multiplies the sum of two
numbers by 10.

#+begin_src lisp

  (defun multiply-sum-by-10 (x y)
    "Returns the sum of two numbers multiplied by 10"
    (* 10 (+ x y)))

  ;; Returns 150

  (multiply-sum-by-10 5 10)

#+end_src


* Blocks

The =PROGN= form allows multiple forms to be evaluated
and the value of the last returned as the value of the
PROGN. For example:

#+begin_src lisp

  ;; Returns 10
    
  (progn
    (print "Hello")
    (print "World")
    (+ 5 5))

#+end_src

The =BLOCK= special operator is similar, but it is named and has a
mechanism for out-of-order exit with the =RETURN-FROM= operator.
The bodies of functions are wrapped in an implicit BLOCK.

#+begin_src lisp

  ;; Returns 10
  
  (block my-block
    (print "We see this")
    (return-from my-block 10)
    (print "We will never see this"))

#+end_src

The =RETURN= macro returns its argument as the value of an enclosing
BLOCK named NIL.  Many Common Lisp operators that take a body of
expressions implicitly enclose the body in a BLOCK named NIL and we
can use RETURN in these forms:

 #+begin_src lisp

   ;; Returns 10 when 1 = 3 and
   ;; prints 1 and 2
   
   (dolist (i '(1 2 3 5 6 7))
     (if (= i 3)
	 (return 10))
     (print i))

 #+end_src

The value of the last expression is returned by the block (unless
modified by RETURN or RETURN-FROM). All other expressions in the block
are thus only useful for their side effects.


* Numerical Functions

Basic numerical functions include =+=, =*=, =-=, =/=. They can
take more than two operands, e.g.:

#+begin_src lisp

  ;; Returns 20

  (+ 4 7 9)

#+end_src

Numerical comparisons can be achieved with ===, =/== (not),
=>=, =<=, =>== and =<==. With three or more arguments, these
functions act as range checks.

#+begin_src lisp

  (defparameter x 5)
  
  (defparameter y 4)

  
  ;; Returns true as x between 0 and 5 inclusive
  
  (<= 0 x 5)

  
  ;; Returns false as x not between 0 and 5 exclusive
  
  (< 0 x 5)

  
  ;; Returns false as x > y

  (< 0 x y 6)

  expt
  ;; Returns true

  (< 0 y x 6)

#+end_src

=MAX=, =MIN=, =ABS= and =EXPT= are also useful numerical functions.


* Text Functions

Four useful text functions are =CONCATENATE= to join strings,
=LENGTH= to get their length, =SUBSEQ= to extract a portion of a
string and =SEARCH= to search within a string (which returns NIL
if not found).

#+begin_src lisp

  (concatenate 'string "Hello, " "world" ". Today is good.")


  ;; Returns 6

  (length "Common")
  

  ;; Returns 4
  
  (search "term" "the term is search within this string")

#+end_src


Below are comparison functions for strings. Replace STRING with
CHAR in the below to get the equivalent character comparison
function. 

| Case Sensitive | Case Insensitive    |
|----------------+---------------------|
| STRING=        | STRING-EQUAL        |
| STRING/=       | STRING-NOT-EQUAL    |
| STRING<        | STRING-LESSP        |
| STRING<=       | STRING-NOT-GREATERP |
| STRING>        | STRING-GREATERP     |
| STRING>=       | STRING-NOT-LESSP    |


* Data Types

One can get the data types of a LISP object with =TYPE-0F= and
test whether a object is of a particular type with =TYPEP=.

#+begin_src lisp

  (typep "My String" 'string)

  (type-of "My String")

#+end_src

Other type predicate functions include ATOM, NULL, ZEROP,
NUMBERP, EVENP, LISTP, ARRAYP, PLUSP, CHARACTERP, ODDP,
SYMBOLP, PACKAGEP, MINUSP, STRINGP and ODDP.


* Boolean & Equality

The function AND returns NIL if any of its arguments are false and
returns the value of the last argument if all arguments are true.  The
function OR returns the first argument that is true and NIL if no
argument is true.

#+begin_src lisp

  ;; Returns 5
  
  (and t (+ 1 2) (* 1 5))

  ;; Returns 3
  
  (or nil (+ 1 2) (* 1 5))

#+end_src

Common Lisp has a few different functions for testing equality of two
objects. Generally speaking, you can't go wrong with =EQUAL=.

- =EQ= compares equality of memory addresses and is the fastest
  test. It is useful to compare symbols quickly and to test whether two
  cons cells are physically the same object. It should not be used to
  compare numbers.

- =EQL= is like EQ except that it can safely compare numbers for numerical
  equality and type equality. It is the default equality test in many
  Common Lisp functions.

- =EQUAL= is a general purpose test that, in addition to being able to
  safely compare numbers like EQL, can safely compare lists on an
  element by element basis. Lists are not unique and EQ and EQL will
  fail to return equality on equivalent lists if they are stored in
  different memory addresses.

- =EQUALP= is a more liberal version of EQUAL. It ignores case
  distinctions in strings, among other things.

- === is the most efficient way to compare numbers, and the only way to
  compare numbers of disparate types, such as 3 and 3.0. It only accepts
  numbers.


* Conditionals

The five main conditionals in Common Lisp are IF, WHEN, UNLESS, COND
and CASE. Conditionals with an implicit PROGN block allow for multiple
forms within their bodies.

Example of IF form (note there is no implicit PROGN):


#+begin_src lisp

  (if (equal 5 (+ 1 4))
      (print "This is true")
      (print "This if false"))

#+end_src

Example of WHEN form (note there is an implicit PROGN):

#+begin_src lisp

  (when (equal 5 (+ 1 4))
    (print "Print if statement is true")
    (print "Print this also"))

#+end_src

Example of UNLESS form (note there is an implicit PROGN):

#+begin_src lisp

  (unless (equal 3 (+ 1 4))
    (print "Only print if condition is false")
    (print "Print this also"))

#+end_src

Example of COND form (multiple ifs, implicit PROGN). The form exits on
the first true:
	
#+begin_src lisp

  (cond ((equal 5 3) (print "This will not print"))
	((equal 5 5) (print "This will print"))
	((equal 5 5)
	 (print "This will not print as the")
	 (print "form exited at first true")))

#+end_src

Example of a CASE form (multiple ifs on the one variable, implicit
PROGN). Cases are literal not evaluated. The form exits on the first true:

#+begin_src lisp

  ;; Try entering in 9 and then (* 3 3)
  ;; at the read prompt. Then try entering 0
  
  (case (read)
     ((1 3 5 7 9 (* 3 3)) "Odd")
    (* 3 3)
    (0 ; Note implicit PROGN here
     (print "Zero")
     (print "Number"))
    (otherwise "Not a odd number < 10"))

#+end_src


* Basic Looping

=DOLIST= and =DOTIMES= are basic loop macros. DOLIST will iterate over
the items of my-list and execute the loop body for each item of the list.
In the below, my-variable holds the value of each successive item in the
list during the iteration.

#+begin_src lisp

  (dolist (my-variable my-list optional-result-form)
    body-form*)

#+end_src

#+begin_src lisp

   (dolist (i '(1 2 3 5 6 7))
     (print i))

#+end_src

In the below example, DOTIMES will iterate my-variable from 0 to one
less than the end-number supplied. If an optional-result-form is
supplied, it will be evaluated at the end of the loop. Below is the
structure of the macro, together with an example:

#+begin_src lisp

  (dotimes (my-variable end-number optional-result-form)
    body-form*)

#+end_src

#+begin_src lisp

  (dotimes (i 5 T)
    (print i))

#+end_src


* Local Variables

LET and LET* are special operators that allow us to create local
variables that can only be accessed within their closures. LET binds
its variables in parallel such that you cannot refer to another
variable in the LET form when setting the value of another. LET* binds
its variables in sequentially, so that you can refer to the value of
any previously bound variables. This is useful when you want to assign
names to several intermediate steps in a long computation.

The LET form has the following syntax:

#+begin_src elisp

  (let ((var-1 value-1)
	...
	(var-n value-n))
    body-form*)

#+end_src

An example of LET* in use:

 #+begin_src lisp

   ;; Prints 10
   
   (let* ((x 5)
	  (y (+ x x)))
     (print y))

 #+end_src


* Local Functions

Functions named by DEFUN are global functions that can be accessed
anywhere. We can define local functions LABELS, which are only accessible
within their context. The syntax of LABELS is:

#+begin_src lisp

  (labels ((fn-1 args-1 body-1)
	   ...
	   (fn-n args-n body-n))
    body-form*)

#+end_src

Functions defined within LABELS take a similar format to a DEFUN
form. Within the body of the LABELS form, function names matching
those defined by the LABELS refer to the locally defined functions
rather than any global functions with the same names. Below is an
example of a LABELS form that will return 12, the result of (+ 2 4 6),
where 2, 4 and 6 are the results of evaluating the three local
functions defined in the form.

#+begin_src lisp

  ;; Returns 12
  
  (labels ((first-function (x) (+ x x))
	   (second-function (y) (* y y))
	   (third-function (z) (first-function z)))
    (+ (first-function 1)
       (second-function 2)
       (third-function 3))) 

#+end_src


* Lambda Expressions

Lambda expressions allow us to create unnamed functions. These are
useful when writing small functions for certain tasks. Below is
an example.

#+begin_src lisp

  ;; Function Form

  (defun my-function (x)
    (+ x 100))

  ;; Returns 101

  (my-function 1)

  ;; Lambda Form
  ;; Also returns 101
  
  ((lambda (x)
     (+ x 100))
   1)

#+end_src


* More on Functions




* List Functions





* Association Lists




* Arrays

The function MAKE-ARRAY allows us to create arrays. For example, we
can create a 2 x 3 array as follows:

#+begin_src lisp

  (defparameter my-array
    (make-array '(2 3) :initial-element nil))

#+end_src

The functions AREF and SETF allow us to access elements and set them
with values:

#+begin_src lisp

  ;; Returns NIL

  (aref my-array 0 0)

  
  ;; Set (0,0) to B
  
  (setf (aref my-array 0 0) 'b)

  
  ;; Returns B

  (aref my-array 0 0)

#+end_src

The functions ARRAY-RANK and ARRAY-DIMENSION retrieve the the number
of dimensions and the number of elements in a given dimension
respectively:

#+begin_src lisp

  (setf my-array
	(make-array '(2 3)
		    :initial-element '((1 2 3) (1 2 3))))

  
  ;; Returns 2

  (array-rank my-array))


  ;; Returns 2

  (array-dimension my-array 0)
  

  ;; Returns 3

  (array-dimension my-array 1)

#+end_src

We use :INITIAL-ELEMENT to set the value of every element of an array
to the provided argument, while we use :INITIAL-CONTENTS to set the
array to the object provided. A one-dimensional array is a vector and
can be created with either of the following.

#+begin_src lisp

(vector "a" 'b 3)
 
(defparameter my-vector
  (make-array 3 :initial-contents '("a" 'b 3)))

#+end_src

Finally, we can create a literal array using the #na syntax, where n
is the number of dimensions:

#+begin_src lisp

  ;; Returns ((B NIL NIL) (1 2 3))

  #2a((b nil nil) (1 2 3))

#+end_src
	
Strings are vectors of characters, denoted with double quotes
(e.g. "my-string"). Strings evaluate to themselves. A character such
as c is denoted as #\c. Each character has an associated integer that
is usually (but not necessarily) its ASCII number:

#+begin_src lisp

  ;; Returns 99
  
  (char-code #\c)

  ;; Returns #\c
  
  (code-char 99) 

#+end_src


* Sequences

The type sequence includes both lists and vectors (and therefore
strings). Sequences have many useful functions:

#+begin_src lisp

  ;; Returns 6

  (length '(a b c d e f))

  ;; Returns (F E D C B A)

  (reverse '(a b c d e f)) 

  ;; Returns (C R T) (a new original list unaffected):

  (remove 'a '(c a r a t))
 	
  ;; Returns "cbdra" (preserves only the last of each):

  (remove-duplicates "abracadabra")

#+end_src

We use SUBSEQ to get a portion of a list. Its arguments are a list,
the starting position and an optional ending position (which is not to
be included in the subsequence):

#+begin_src lisp

  ;; Returns (B C D)
  
  (subseq '(a b c d e f) 1 4)

#+end_src

SORT takes a sequence and a comparison function of two arguments and
destructively (i.e. by modifying the original sequence) returns a
sequence sorted according to the function:

#+begin_src lisp

  ;; Returns (6 5 4 2 1)
  
  (sort '(1 4 2 5 6) #'>) 

#+end_src

The functions EVERY and SOME test whether a sequence satisfies a
provided predicate:

#+begin_src lisp

  ;; Returns NIL

  (every #'oddp '( 1 2 5)) 

  ;; Returns T

  (some #'oddp '( 1 2 5))

  ;; Returns T

  (every #'> '(1 3 5) '(0 2 4))

#+end_src


* Keyword Arguments

Many sequence functions take one or more keyword arguments from the
below table. For example, we can use POSITION to return the position
of an element within a sequence (or NIL if not found) and use keyword
arguments to determine where to begin the search:

	(position #\a "fantasia" :start 3 :end 7) ; Returns 4

| Parameter | Position                            | Default  |
|-----------+-------------------------------------+----------|
| :key      | A function to apply to each element | identity |
| :test     | The test function for comparison    | eql      |
| :from-end | If true, work backwards             | nil      |
| :start    | Position at which to start          | 0        |
| :end      | Position, if any, at which to stop  | nil      |


* Hash Tables

A hash table is a way of associating pairs of objects, like a
dictionary. The objects stored in a hash table or used as keys can be
of any type. We can make hastables with MAKE-HASH-TABLE and retrieve
values associated with a given key with GETHASH:

#+begin_src lisp

  (defparameter my-hash-table (make-hash-table))

  ;; Returns NIL as not yet set
  
  (gethash 'color my-hash-table) 

#+end_src

Similar to other structures, we use SETF to set values. Hash tables
can accommodate any number of elements, because they are expanded when
they run out of space. We can remove values with REMHASH.

#+begin_src lisp

  ;; Returns RED
  
  (setf (gethash 'color my-hash-table) 'red)

  (remhash 'color my-hash-table)

#+end_src

Finally, the function MAPHASH allows you to iterate over all entries
in the hash table. Its first argument must be a function which accepts
two arguments, the key and the value of each entry. Note that due to
the nature of hash tables you can't control the order in which the
entries are provided to MAPHASH (or other traversing constructs):
	
#+begin_src lisp

  (maphash #'(lambda (key value)
	       (format t "~A = ~A~%" key value))
	   my-hash-table)

#+end_src


* Structures

Common Lisp provides the DEFSTRUCT facility for creating named data
structures with named components. This makes it easier to manipulate
custom data objects as we can refer to their components by
name. Constructor, access and assignment constructs are automatically
defined when a data type is defined through DEFSTRUCT.

Consider the below example of defining a data type for rectangles.
DEFSTRUCT defines RECTANGLE to be a structure with two fields,
height and width. The symbol RECTANGLE becomes the name of a data
type and each rectangle will be of type RECTANGLE, then STRUCTURE,
then ATOM and then T. DEFSTRUCT generates four associated functions:

1. RECTANGLE-HEIGHT and RECTANGLE-WIDTH to access elements of the
   structure

2. RECTANGLE-P to test whether an object is of type rectangle

3. MAKE-RECTANGLE to create rectangles

4. COPY-RECTANGLE to create copies of rectangles

* Example of a Structure

#+begin_src lisp

  ;; Height will default to NIL
  ;; Width will default to 5 

  (defstruct rectangle (height)
	     (width 5))
  
  (defvar rectangle-1)

  (setf rectangle-1
	(make-rectangle :height 10 :width 15))
	
  ;; Returns 10
  
  (rectangle-height rectangle-1)

  ;; Returns 20

  (setf (rectangle-width rectangle-1) 20)

  (defvar rectangle-2)

  (setf rectangle-2 (make-rectangle))

  ;; Prints #S(RECTANGLE :HEIGHT NIL :WIDTH 5)
  
  rectangle-2

#+end_src


* Advanced Looping

Below is the syntax and example of the =DO= macro. 

#+begin_src lisp

  (do ((var1 init1 step1)
       ...
       (varn initn stepn))
      (end-test result-forms*)
    body-forms*)

#+end_src

The below example will return 81 and print 1, 0, 1, 4, 9, 16, 25,
36, 49 and 64 on newlines. During each iteration, loop-step is
increased by one while square is set to the square of loop-step.

#+begin_src lisp

  (do ((loop-step 0 (+ loop-step 1))
       (square 1 (* loop-step loop-step)))
      ((= 10 loop-step) square) ; Stop at 10
    (print square)) ; Print square at each step

#+end_src


Below are examples of the =LOOP= macro.


* Reading & Writing to Files

The =WITH-OPEN-FILE= macro is used to read & write to files and then
close the file. Streams are Lisp objects representing sources and/or
destinations of characters. To read from or write to a file, you open
it as a stream. By default, input is read from the stream *​standard-input​*
and output is recorded in *​standard-output​*. Initially they will be the
same place - the toplevel.

Below is an example opening a file as my-stream and then reading from
it. The NIL in the below inhibits end of file errors.

#+begin_src lisp

  (with-open-file (my-stream "/Users/ashokkhanna/test.txt")
    (format t "~a~%" (read-line my-stream nil)))

#+end_src

Below is an example opening a file as my-stream and then writing to
it.

#+begin_src lisp

  (with-open-file (my-stream "/Users/ashokkhanna/test.txt" :direction
			     :output :if-exists :append)
    (format my-stream "~a~%" "Hello, World!"))

#+end_src

The following open arguments can be supplied to the WITH-OPEN-FILE
macro:

| Arguments                  | Effect                             |
|----------------------------+------------------------------------|
| :direction :output         | Write to a file insead of reading  |
| :if-does-not-exist :create | Create a file if it does not exist |
| :if-exists :supersede      | Replace the file that exists       |
| :if-exists :overwrite      | Overwrite file                     |
| :if-exists :append         | Write to end of file               |
