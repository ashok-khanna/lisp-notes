<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<HTML>
<HEAD>
<TITLE>CLHS: Macro WHEN, UNLESS</TITLE>
<LINK HREF="../Data/clhs.css" REL="stylesheet" TYPE="text/css" />
<META HTTP-EQUIV="Author" CONTENT="Kent M. Pitman">
<META HTTP-EQUIV="Organization" CONTENT="LispWorks Ltd.">
<LINK REL=TOP HREF="../Front/index.htm">
<LINK REL=COPYRIGHT HREF="../Front/Help.htm#Legal">
<LINK REL=DISCLAIMER HREF="../Front/Help.htm#Disclaimer">
<LINK REL=PREV HREF="m_or.htm">
<LINK REL=UP HREF="c_data_a.htm">
<LINK REL=NEXT HREF="m_case_.htm">
</HEAD>
<BODY>
<H1><A REV=MADE HREF="http://www.lispworks.com/"><IMG WIDTH=80 HEIGHT=65 ALT="[LISPWORKS]" SRC="../Graphics/LWSmall.gif" ALIGN=Bottom></A><A REL=TOP HREF="../Front/index.htm"><IMG WIDTH=237 HEIGHT=65 ALT="[Common Lisp HyperSpec (TM)]" SRC="../Graphics/CLHS_Sm.gif" ALIGN=Bottom></A> <A REL=PREV HREF="m_or.htm"><IMG WIDTH=40 HEIGHT=40 ALT="[Previous]" SRC="../Graphics/Prev.gif" ALIGN=Bottom></A><A REL=UP HREF="c_data_a.htm"><IMG WIDTH=40 HEIGHT=40 ALT="[Up]" SRC="../Graphics/Up.gif" ALIGN=Bottom></A><A REL=NEXT HREF="m_case_.htm"><IMG WIDTH=40 HEIGHT=40 ALT="[Next]" SRC="../Graphics/Next.gif" ALIGN=Bottom></A></H1>

<HR>

<A NAME="when"><A NAME="unless"><I>Macro</I> <B>WHEN, UNLESS</B></A></A> <P>
<P><B>Syntax:</B><P>
 <P>

<B>when</B> <I>test-form <I>form</I><B>*</B></I> =&gt; <I><I>result</I><B>*</B></I><P>
 <P>

<B>unless</B> <I>test-form <I>form</I><B>*</B></I> =&gt; <I><I>result</I><B>*</B></I><P>
 <P>
<P><B>Arguments and Values:</B><P>
 <P>
<I>test-form</I>---a <A REL=DEFINITION HREF="26_glo_f.htm#form"><I>form</I></A>. <P>
<I>forms</I>---an <A REL=DEFINITION HREF="26_glo_i.htm#implicit_progn"><I>implicit progn</I></A>. <P>
<I>results</I>---the <A REL=DEFINITION HREF="26_glo_v.htm#value"><I>values</I></A> of the <A REL=DEFINITION HREF="26_glo_f.htm#form"><I>forms</I></A> in a <A REL=DEFINITION HREF="#when"><B>when</B></A> <A REL=DEFINITION HREF="26_glo_f.htm#form"><I>form</I></A> if the <I>test-form</I> <A REL=DEFINITION HREF="26_glo_y.htm#yield"><I>yields</I></A> <A REL=DEFINITION HREF="26_glo_t.htm#true"><I>true</I></A> or in an <A REL=DEFINITION HREF="#unless"><B>unless</B></A> <A REL=DEFINITION HREF="26_glo_f.htm#form"><I>form</I></A> if the <I>test-form</I> <A REL=DEFINITION HREF="26_glo_y.htm#yield"><I>yields</I></A> <A REL=DEFINITION HREF="26_glo_f.htm#false"><I>false</I></A>; otherwise <A REL=DEFINITION HREF="a_nil.htm#nil"><B>nil</B></A>. <P>
<P><B>Description:</B><P>
 <P>
<A REL=DEFINITION HREF="#when"><B>when</B></A> and <A REL=DEFINITION HREF="#unless"><B>unless</B></A> allow the execution of <I>forms</I> to be dependent on a single <I>test-form</I>. <P>
In a <A REL=DEFINITION HREF="#when"><B>when</B></A> <A REL=DEFINITION HREF="26_glo_f.htm#form"><I>form</I></A>, if the <I>test-form</I> <A REL=DEFINITION HREF="26_glo_y.htm#yield"><I>yields</I></A> <A REL=DEFINITION HREF="26_glo_t.htm#true"><I>true</I></A>, the <I>forms</I> are <I>evaluated</I> in order from left to right and the <A REL=DEFINITION HREF="26_glo_v.htm#value"><I>values</I></A> returned by the <I>forms</I> are returned from the <A REL=DEFINITION HREF="#when"><B>when</B></A> <A REL=DEFINITION HREF="26_glo_f.htm#form"><I>form</I></A>. Otherwise, if the <I>test-form</I> <A REL=DEFINITION HREF="26_glo_y.htm#yield"><I>yields</I></A> <A REL=DEFINITION HREF="26_glo_f.htm#false"><I>false</I></A>, the <I>forms</I> are not <I>evaluated</I>, and the <A REL=DEFINITION HREF="#when"><B>when</B></A> <A REL=DEFINITION HREF="26_glo_f.htm#form"><I>form</I></A> returns <A REL=DEFINITION HREF="a_nil.htm#nil"><B>nil</B></A>. <P>
In an <A REL=DEFINITION HREF="#unless"><B>unless</B></A> <A REL=DEFINITION HREF="26_glo_f.htm#form"><I>form</I></A>, if the <I>test-form</I> <A REL=DEFINITION HREF="26_glo_y.htm#yield"><I>yields</I></A> <A REL=DEFINITION HREF="26_glo_f.htm#false"><I>false</I></A>, the <I>forms</I> are <I>evaluated</I> in order from left to right and the <A REL=DEFINITION HREF="26_glo_v.htm#value"><I>values</I></A> returned by the <I>forms</I> are returned from the <A REL=DEFINITION HREF="#unless"><B>unless</B></A> <A REL=DEFINITION HREF="26_glo_f.htm#form"><I>form</I></A>. Otherwise, if the <I>test-form</I> <A REL=DEFINITION HREF="26_glo_y.htm#yield"><I>yields</I></A> <A REL=DEFINITION HREF="26_glo_f.htm#false"><I>false</I></A>, the <I>forms</I> are not <I>evaluated</I>, and the <A REL=DEFINITION HREF="#unless"><B>unless</B></A> <A REL=DEFINITION HREF="26_glo_f.htm#form"><I>form</I></A> returns <A REL=DEFINITION HREF="a_nil.htm#nil"><B>nil</B></A>. <P>
<P><B>Examples:</B><P>
 <P>
<PRE>
 (when t 'hello) =&gt;  HELLO
 (unless t 'hello) =&gt;  NIL
 (when nil 'hello) =&gt;  NIL
 (unless nil 'hello) =&gt;  HELLO
 (when t) =&gt;  NIL
 (unless nil) =&gt;  NIL
 (when t (prin1 1) (prin1 2) (prin1 3))
&gt;&gt;  123
=&gt;  3
 (unless t (prin1 1) (prin1 2) (prin1 3)) =&gt;  NIL
 (when nil (prin1 1) (prin1 2) (prin1 3)) =&gt;  NIL
 (unless nil (prin1 1) (prin1 2) (prin1 3))
&gt;&gt;  123
=&gt;  3
 (let ((x 3))
   (list (when (oddp x) (incf x) (list x))
         (when (oddp x) (incf x) (list x))
         (unless (oddp x) (incf x) (list x))
         (unless (oddp x) (incf x) (list x))
         (if (oddp x) (incf x) (list x)) 
         (if (oddp x) (incf x) (list x)) 
         (if (not (oddp x)) (incf x) (list x)) 
         (if (not (oddp x)) (incf x) (list x))))
=&gt;  ((4) NIL (5) NIL 6 (6) 7 (7))
</PRE>
</TT> <P>
<P><B>Side Effects:</B> None.
 <P>
<P><B>Affected By:</B> None.
 <P>
<P><B>Exceptional Situations:</B> None.
 <P>
<P><B>See Also:</B><P>
 <P>
<A REL=DEFINITION HREF="m_and.htm#and"><B>and</B></A>, <A REL=DEFINITION HREF="m_cond.htm#cond"><B>cond</B></A>, <A REL=DEFINITION HREF="s_if.htm#if"><B>if</B></A>, <A REL=DEFINITION HREF="m_or.htm#or"><B>or</B></A> <P>
<P><B>Notes:</B><P>
 <P>
<PRE>
 (when test {form}+) ==  (and test (progn {form}+))
 (when test {form}+) ==  (cond (test {form}+))
 (when test {form}+) ==  (if test (progn {form}+) nil)
 (when test {form}+) ==  (unless (not test) {form}+)
 (unless test {form}+) ==  (cond ((not test) {form}+))
 (unless test {form}+) ==  (if test nil (progn {form}+))
 (unless test {form}+) ==  (when (not test) {form}+)
</PRE>
</TT> <P>
<HR>

<A REL=NAVIGATOR HREF="../Front/StartPts.htm"><IMG WIDTH=80 HEIGHT=40 ALT="[Starting Points]" SRC="../Graphics/StartPts.gif" ALIGN=Bottom></A><A REL=TOC HREF="../Front/Contents.htm"><IMG WIDTH=80 HEIGHT=40 ALT="[Contents]" SRC="../Graphics/Contents.gif" ALIGN=Bottom></A><A REL=INDEX HREF="../Front/X_Master.htm"><IMG WIDTH=80 HEIGHT=40 ALT="[Index]" SRC="../Graphics/Index.gif" ALIGN=Bottom></A><A REL=INDEX HREF="../Front/X_Symbol.htm"><IMG WIDTH=80 HEIGHT=40 ALT="[Symbols]" SRC="../Graphics/Symbols.gif" ALIGN=Bottom></A><A REL=GLOSSARY HREF="../Body/26_a.htm"><IMG WIDTH=80 HEIGHT=40 ALT="[Glossary]" SRC="../Graphics/Glossary.gif" ALIGN=Bottom></A><A HREF="../Front/X3J13Iss.htm"><IMG WIDTH=80 HEIGHT=40 ALT="[Issues]" SRC="../Graphics/Issues.gif" ALIGN=Bottom></A><BR>

<A REL=COPYRIGHT HREF="../Front/Help.htm#Legal"><I>Copyright 1996-2005, LispWorks Ltd.  All rights reserved.</I></A><P>
</BODY>
</HTML>
