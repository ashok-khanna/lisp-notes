<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<HTML>
<HEAD>
<TITLE>CLHS: Function EQUALP</TITLE>
<LINK HREF="../Data/clhs.css" REL="stylesheet" TYPE="text/css" />
<META HTTP-EQUIV="Author" CONTENT="Kent M. Pitman">
<META HTTP-EQUIV="Organization" CONTENT="LispWorks Ltd.">
<LINK REL=TOP HREF="../Front/index.htm">
<LINK REL=COPYRIGHT HREF="../Front/Help.htm#Legal">
<LINK REL=DISCLAIMER HREF="../Front/Help.htm#Disclaimer">
<LINK REL=PREV HREF="f_equal.htm">
<LINK REL=UP HREF="c_data_a.htm">
<LINK REL=NEXT HREF="f_identi.htm">
</HEAD>
<BODY>
<H1><A REV=MADE HREF="http://www.lispworks.com/"><IMG WIDTH=80 HEIGHT=65 ALT="[LISPWORKS]" SRC="../Graphics/LWSmall.gif" ALIGN=Bottom></A><A REL=TOP HREF="../Front/index.htm"><IMG WIDTH=237 HEIGHT=65 ALT="[Common Lisp HyperSpec (TM)]" SRC="../Graphics/CLHS_Sm.gif" ALIGN=Bottom></A> <A REL=PREV HREF="f_equal.htm"><IMG WIDTH=40 HEIGHT=40 ALT="[Previous]" SRC="../Graphics/Prev.gif" ALIGN=Bottom></A><A REL=UP HREF="c_data_a.htm"><IMG WIDTH=40 HEIGHT=40 ALT="[Up]" SRC="../Graphics/Up.gif" ALIGN=Bottom></A><A REL=NEXT HREF="f_identi.htm"><IMG WIDTH=40 HEIGHT=40 ALT="[Next]" SRC="../Graphics/Next.gif" ALIGN=Bottom></A></H1>

<HR>

<A NAME="equalp"><I>Function</I> <B>EQUALP</B></A> <P>
<P><B>Syntax:</B><P>
 <P>

<B>equalp</B> <I>x y</I> =&gt; <I>generalized-boolean</I><P>
 <P>
<P><B>Arguments and Values:</B><P>
 <P>
<I>x</I>---an <A REL=DEFINITION HREF="26_glo_o.htm#object"><I>object</I></A>. <P>
<I>y</I>---an <A REL=DEFINITION HREF="26_glo_o.htm#object"><I>object</I></A>. <P>
<I>generalized-boolean</I>---a <A REL=DEFINITION HREF="26_glo_g.htm#generalized_boolean"><I>generalized boolean</I></A>. <P>
<P><B>Description:</B><P>
 <P>
Returns <A REL=DEFINITION HREF="26_glo_t.htm#true"><I>true</I></A> if <I>x</I> and <I>y</I> are <A REL=DEFINITION HREF="f_equal.htm#equal"><B>equal</B></A>, or if they have components that are of the same <A REL=DEFINITION HREF="26_glo_t.htm#type"><I>type</I></A> as each other and if those components are <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A>; specifically, <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A> returns <A REL=DEFINITION HREF="26_glo_t.htm#true"><I>true</I></A> in the following cases: <P><DL><DT><A REL=DEFINITION HREF="26_glo_c.htm#character"><I>Characters</I></A>  <P><DD>
If two <A REL=DEFINITION HREF="26_glo_c.htm#character"><I>characters</I></A> are <A REL=DEFINITION HREF="f_chareq.htm#char-equal"><B>char-equal</B></A>. <P>
<DT><A REL=DEFINITION HREF="26_glo_n.htm#number"><I>Numbers</I></A>  <P><DD>
If two <A REL=DEFINITION HREF="26_glo_n.htm#number"><I>numbers</I></A> are the <A REL=DEFINITION HREF="26_glo_s.htm#same"><I>same</I></A> under <A REL=DEFINITION HREF="f_eq_sle.htm#EQ"><B>=</B></A>. <P>
<DT><A REL=DEFINITION HREF="26_glo_c.htm#cons"><I>Conses</I></A>  <P><DD>
If the two <A REL=DEFINITION HREF="26_glo_c.htm#car"><I>cars</I></A> in the <A REL=DEFINITION HREF="26_glo_c.htm#cons"><I>conses</I></A> are <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A> and the two <A REL=DEFINITION HREF="26_glo_c.htm#cdr"><I>cdrs</I></A> in the <A REL=DEFINITION HREF="26_glo_c.htm#cons"><I>conses</I></A> are <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A>. <P>
<DT><A REL=DEFINITION HREF="26_glo_a.htm#array"><I>Arrays</I></A>  <P><DD>
If two <A REL=DEFINITION HREF="26_glo_a.htm#array"><I>arrays</I></A> have the same number of dimensions, the dimensions match, and the corresponding <A REL=DEFINITION HREF="26_glo_a.htm#active"><I>active</I></A> <A REL=DEFINITION HREF="26_glo_e.htm#element"><I>elements</I></A> are <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A>. The <A REL=DEFINITION HREF="26_glo_t.htm#type"><I>types</I></A> for which the <A REL=DEFINITION HREF="26_glo_a.htm#array"><I>arrays</I></A> are <A REL=DEFINITION HREF="26_glo_s.htm#specialized"><I>specialized</I></A> need not match; for example, a <A REL=DEFINITION HREF="26_glo_s.htm#string"><I>string</I></A> and a general <A REL=DEFINITION HREF="26_glo_a.htm#array"><I>array</I></A> that happens to contain the same <A REL=DEFINITION HREF="26_glo_c.htm#character"><I>characters</I></A> are <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A>. Because <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A> performs <A REL=DEFINITION HREF="26_glo_e.htm#element"><I>element</I></A>-by-<A REL=DEFINITION HREF="26_glo_e.htm#element"><I>element</I></A> comparisons of <A REL=DEFINITION HREF="26_glo_s.htm#string"><I>strings</I></A> and ignores the <A REL=DEFINITION HREF="26_glo_c.htm#case"><I>case</I></A> of <A REL=DEFINITION HREF="26_glo_c.htm#character"><I>characters</I></A>, <A REL=DEFINITION HREF="26_glo_c.htm#case"><I>case</I></A> distinctions are ignored when <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A> compares <A REL=DEFINITION HREF="26_glo_s.htm#string"><I>strings</I></A>. <P>
 <DT><A REL=DEFINITION HREF="26_glo_s.htm#structure"><I>Structures</I></A>  <P><DD>
If two <A REL=DEFINITION HREF="26_glo_s.htm#structure"><I>structures</I></A> S1 and S2 have the same <A REL=DEFINITION HREF="26_glo_c.htm#class"><I>class</I></A> and the value of each <A REL=DEFINITION HREF="26_glo_s.htm#slot"><I>slot</I></A> in S1 is the <A REL=DEFINITION HREF="26_glo_s.htm#same"><I>same</I></A> under <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A> as the value of the corresponding <A REL=DEFINITION HREF="26_glo_s.htm#slot"><I>slot</I></A> in S2. <P>
<DT><A REL=DEFINITION HREF="26_glo_h.htm#hash_table"><I>Hash Tables</I></A>  <P><DD>
<A REL=DEFINITION HREF="#equalp"><B>equalp</B></A> descends <I>hash-tables</I> by first comparing the count of entries and the <TT>:test</TT> function; if those are the same, it compares the keys of the tables using the <TT>:test</TT> function and then the values of the matching keys using <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A> recursively.  <P>
<P></DL><P>
 <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A> does not descend any <A REL=DEFINITION HREF="26_glo_o.htm#object"><I>objects</I></A> other than the ones explicitly specified above. The next figure summarizes the information given in the previous list. In addition, the figure specifies the priority of the behavior of <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A>, with upper entries taking priority over lower ones. <P>
<PRE>
Type          Behavior                      
<A REL=DEFINITION HREF="26_glo_n.htm#number">number</A>        uses <A REL=DEFINITION HREF="f_eq_sle.htm#EQ">=</A>                        
<A REL=DEFINITION HREF="26_glo_c.htm#character">character</A>     uses <A REL=DEFINITION HREF="f_chareq.htm#char-equal">char-equal</A>               
<A REL=DEFINITION HREF="26_glo_c.htm#cons">cons</A>          descends                      
<A REL=DEFINITION HREF="26_glo_b.htm#bit_vector">bit vector</A>    descends                      
<A REL=DEFINITION HREF="26_glo_s.htm#string">string</A>        descends                      
<A REL=DEFINITION HREF="26_glo_p.htm#pathname">pathname</A>      same as <A REL=DEFINITION HREF="f_equal.htm#equal">equal</A>                 
<A REL=DEFINITION HREF="26_glo_s.htm#structure">structure</A>     descends, as described above  
Other <A REL=DEFINITION HREF="26_glo_a.htm#array">array</A>   descends                      
<A REL=DEFINITION HREF="26_glo_h.htm#hash_table">hash table</A>    descends, as described above  
Other <A REL=DEFINITION HREF="26_glo_o.htm#object">object</A>  uses <A REL=DEFINITION HREF="f_eq.htm#eq">eq</A>                       
</PRE>
<P><B>Figure 5-13.  Summary and priorities of behavior of <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A></B>  <P>
<P><B>Examples:</B><P>
 <P>
<PRE>
 (equalp 'a 'b) =&gt;  <A REL=DEFINITION HREF="26_glo_f.htm#false">false</A>
 (equalp 'a 'a) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
 (equalp 3 3) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
 (equalp 3 3.0) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
 (equalp 3.0 3.0) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
 (equalp #c(3 -4) #c(3 -4)) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
 (equalp #c(3 -4.0) #c(3 -4)) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
 (equalp (cons 'a 'b) (cons 'a 'c)) =&gt;  <A REL=DEFINITION HREF="26_glo_f.htm#false">false</A>
 (equalp (cons 'a 'b) (cons 'a 'b)) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
 (equalp #\A #\A) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
 (equalp #\A #\a) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
 (equalp &quot;Foo&quot; &quot;Foo&quot;) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
 (equalp &quot;Foo&quot; (copy-seq &quot;Foo&quot;)) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
 (equalp &quot;FOO&quot; &quot;foo&quot;) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
</PRE>
</TT> 
<PRE>
 (setq array1 (make-array 6 :element-type 'integer
                            :initial-contents '(1 1 1 3 5 7))) 
=&gt;  #(1 1 1 3 5 7)
 (setq array2 (make-array 8 :element-type 'integer
                            :initial-contents '(1 1 1 3 5 7 2 6)
                            :fill-pointer 6))
=&gt;  #(1 1 1 3 5 7)
 (equalp array1 array2) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A>
 (setq vector1 (vector 1 1 1 3 5 7)) =&gt;  #(1 1 1 3 5 7)
 (equalp array1 vector1) =&gt;  <A REL=DEFINITION HREF="26_glo_t.htm#true">true</A> 
</PRE>
</TT> <P>
<P><B>Side Effects:</B> None.
 <P>
<P><B>Affected By:</B> None.
 <P>
<P><B>Exceptional Situations:</B> None.
 <P>
<P><B>See Also:</B><P>
 <P>
<A REL=DEFINITION HREF="f_eq.htm#eq"><B>eq</B></A>, <A REL=DEFINITION HREF="f_eql.htm#eql"><B>eql</B></A>, <A REL=DEFINITION HREF="f_equal.htm#equal"><B>equal</B></A>, <A REL=DEFINITION HREF="f_eq_sle.htm#EQ"><B>=</B></A>, <A REL=DEFINITION HREF="f_stgeq_.htm#stringEQ"><B>string=</B></A>, <A REL=DEFINITION HREF="f_stgeq_.htm#string-equal"><B>string-equal</B></A>, <A REL=DEFINITION HREF="f_chareq.htm#charEQ"><B>char=</B></A>, <A REL=DEFINITION HREF="f_chareq.htm#char-equal"><B>char-equal</B></A> <P>
<P><B>Notes:</B><P>
 <P>
 <A REL=DEFINITION HREF="26_glo_o.htm#object"><I>Object</I></A> equality is not a concept for which there is a uniquely determined correct algorithm. The appropriateness of an equality predicate can be judged only in the context of the needs of some particular program. Although these functions take any type of argument and their names sound very generic, <A REL=DEFINITION HREF="f_equal.htm#equal"><B>equal</B></A> and <A REL=DEFINITION HREF="#equalp"><B>equalp</B></A> are not appropriate for every application.  <P>
<P><HR>The following <A REL=META HREF="../Front/X3J13Iss.htm">X3J13 cleanup issue</A>, <I>not part of the specification</I>, applies to this section:<P><UL><LI> <A REL=CHILD HREF="../Issues/iss143.htm">EQUAL-STRUCTURE:MAYBE-STATUS-QUO</A><P></UL><HR>

<A REL=NAVIGATOR HREF="../Front/StartPts.htm"><IMG WIDTH=80 HEIGHT=40 ALT="[Starting Points]" SRC="../Graphics/StartPts.gif" ALIGN=Bottom></A><A REL=TOC HREF="../Front/Contents.htm"><IMG WIDTH=80 HEIGHT=40 ALT="[Contents]" SRC="../Graphics/Contents.gif" ALIGN=Bottom></A><A REL=INDEX HREF="../Front/X_Master.htm"><IMG WIDTH=80 HEIGHT=40 ALT="[Index]" SRC="../Graphics/Index.gif" ALIGN=Bottom></A><A REL=INDEX HREF="../Front/X_Symbol.htm"><IMG WIDTH=80 HEIGHT=40 ALT="[Symbols]" SRC="../Graphics/Symbols.gif" ALIGN=Bottom></A><A REL=GLOSSARY HREF="../Body/26_a.htm"><IMG WIDTH=80 HEIGHT=40 ALT="[Glossary]" SRC="../Graphics/Glossary.gif" ALIGN=Bottom></A><A HREF="../Front/X3J13Iss.htm"><IMG WIDTH=80 HEIGHT=40 ALT="[Issues]" SRC="../Graphics/Issues.gif" ALIGN=Bottom></A><BR>

<A REL=COPYRIGHT HREF="../Front/Help.htm#Legal"><I>Copyright 1996-2005, LispWorks Ltd.  All rights reserved.</I></A><P>
</BODY>
</HTML>
