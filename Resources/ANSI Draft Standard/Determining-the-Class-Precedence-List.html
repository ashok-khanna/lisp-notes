<html lang="en">

<!-- Mirrored from mr.gy/ansi-common-lisp/Determining-the-Class-Precedence-List.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 10 Sep 2021 20:40:19 GMT -->
<head>
<title>Determining the Class Precedence List - ANSI Common Lisp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="ANSI Common Lisp">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index-2.html#Top">
<link rel="up" href="Classes.html#Classes" title="Classes">
<link rel="prev" href="Inheritance.html#Inheritance" title="Inheritance">
<link rel="next" href="Redefining-Classes.html#Redefining-Classes" title="Redefining Classes">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
body {font-family: century schoolbook, serif;
      line-height: 1.3;
      padding-left: 5em; padding-right: 1em;
      padding-bottom: 1em; max-width: 60em;}
table {border-collapse: collapse}
span.roman { font-family: century schoolbook, serif; font-weight: normal; }
h1, h2, h3, h4, h5, h6 {font-family:  Helvetica, sans-serif}
dfn {font-family: inherit; font-variant: italic; font-weight: bolder }
kbd {font-family: monospace; text-decoration: underline}
var {font-family: Helvetica, sans-serif; font-variant: slanted}
td  {padding-right: 1em; padding-left: 1em}
sub {font-size: smaller}
.node {padding: 0; margin: 0}
--></style>
</head>
<body>
<div class="node">
<a name="Determining-the-Class-Precedence-List"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Redefining-Classes.html#Redefining-Classes">Redefining Classes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Inheritance.html#Inheritance">Inheritance</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Classes.html#Classes">Classes</a>
<hr>
</div>

<h4 class="subsection">4.3.5 Determining the Class Precedence List</h4>

<p>The <code>defclass</code> form for a <i>class</i> provides a total ordering
on that <i>class</i> and its direct <i>superclasses</i>.  This ordering is
called the <a name="index-local-precedence-order-347"></a><dfn>local precedence order</dfn>.  It is an ordered list of the
<i>class</i> and its direct <i>superclasses</i>. The
<a name="index-class-precedence-list-348"></a><dfn>class precedence list</dfn> for a class C is a total ordering on
C and its <i>superclasses</i> that is consistent with the
<i>local precedence orders</i> for each of C and its <i>superclasses</i>.

<p>A <i>class</i> precedes its direct <i>superclasses</i>,
and a direct <i>superclass</i> precedes all other
direct <i>superclasses</i> specified to its right
in the <i>superclasses</i> list of the <code>defclass</code> form. 
For every class C, define
<blockquote>
R<sub>C</sub>=<tt>{</tt>(C,C<sub>1</sub>),(C<sub>1</sub>,C<sub>2</sub>),<small class="dots">...</small>,(C<sub>n-1</sub>,C<sub>n</sub>)<tt>}</tt>
</blockquote>
 where C<sub>1</sub>,<small class="dots">...</small>,C<sub>n</sub> are
the direct <i>superclasses</i> of C in the order in which
they are mentioned in the <code>defclass</code> form. These ordered pairs
generate the total ordering on the class C and its direct
<i>superclasses</i>.

<p>Let S<sub>C</sub> be the set of C and its <i>superclasses</i>. Let R be

<blockquote>
R=⋃<sub>c∈ S<sub>C</sub></sub>R<sub>c</sub>

</blockquote>
.

<p>The set R might or might not generate a partial ordering, depending on
whether the R<sub>c</sub>, c∈ S<sub>C</sub>, are
consistent; it is assumed
that they are consistent and that R generates a partial ordering. 
When the R<sub>c</sub> are not consistent, it is said that R is inconsistent.

<p>To compute the <i>class precedence list</i> for&nbsp;C,
topologically sort the elements of S<sub>C</sub> with respect to the
partial ordering generated by R.  When the topological
sort must select a <i>class</i> from a set of two or more
<i>classes</i>, none of
which are preceded by other <i>classes</i> with respect to&nbsp;R,
the <i>class</i> selected is chosen deterministically, as described below.

<p>If R is inconsistent, an error is signaled.

<h5 class="subsubsection">4.3.5.1 Topological Sorting</h5>

<p>Topological sorting proceeds by finding a class C in&nbsp;S<sub>C</sub> such
that no other <i>class</i> precedes that element according to the elements
in&nbsp;R.  The class C is placed first in the result. 
Remove C from S<sub>C</sub>, and remove all pairs of the form (C,D),
D∈ S<sub>C</sub>, from R. Repeat the process, adding
<i>classes</i> with no predecessors to the end of the result.  Stop when no
element can be found that has no predecessor.

<p>If S<sub>C</sub> is not empty and the process has stopped, the set R is
inconsistent. If every <i>class</i> in the finite set of
<i>classes</i> is preceded
by another, then R contains a loop. That is, there is a chain of
classes C<sub>1</sub>,<small class="dots">...</small>,C<sub>n</sub> such that C<sub>i</sub> precedes
C<sub>i+1</sub>, 1≤ i&lt;n, and C<sub>n</sub> precedes C<sub>1</sub>.

<p>Sometimes there are several <i>classes</i> from S<sub>C</sub> with no
predecessors.  In this case select the one that has a direct
<i>subclass</i> rightmost in the <i>class precedence list</i> computed so far. 
(If there is no such candidate <i>class</i>, R does not generate
a partial ordering&mdash;the R<sub>c</sub>, c∈ S<sub>C</sub>, are inconsistent.)

<p>In more precise terms, let <tt>{</tt>N<sub>1</sub>,<small class="dots">...</small>,N<sub>m</sub><tt>}</tt>, m≥ 2, be
the <i>classes</i> from S<sub>C</sub> with no predecessors.  Let (C<sub>1</sub><small class="dots">...</small> C<sub>n</sub>), n≥ 1, be the <i>class precedence list</i>
constructed so far.  C<sub>1</sub> is the most specific <i>class</i>, and C<sub>n</sub> is the least specific.  Let 1≤ j≤ n be the largest number
such that there exists an i where 1≤ i≤ m and N<sub>i</sub>

<p>is a direct <i>superclass</i> of C<sub>j</sub>; N<sub>i</sub> is placed next.

<p>The effect of this rule for selecting from a set of <i>classes</i> with no
predecessors is that the <i>classes</i> in a simple <i>superclass</i> chain are
adjacent in the <i>class precedence list</i> and that <i>classes</i> in each
relatively separated subgraph are adjacent in the <i>class precedence list</i>. 
For example, let T<sub>1</sub> and T<sub>2</sub> be subgraphs whose only
element in common is the class J. 
Suppose that no superclass of J appears in either T<sub>1</sub> or T<sub>2</sub>,
and that J is in the superclass chain of every class in both T<sub>1</sub> and T<sub>2</sub>. 
Let C<sub>1</sub> be the bottom of T<sub>1</sub>;
and let C<sub>2</sub> be the bottom of T<sub>2</sub>. 
Suppose C is a <i>class</i> whose direct <i>superclasses</i>
are C<sub>1</sub> and C<sub>2</sub> in that order, then the <i>class precedence list</i>
for C starts with C and is followed by
all <i>classes</i> in T<sub>1</sub> except J. 
All the <i>classes</i> of T<sub>2</sub> are next. 
The <i>class</i> J and its <i>superclasses</i> appear last.

<h5 class="subsubsection">4.3.5.2 Examples of Class Precedence List Determination</h5>

<p>This example determines a <i>class precedence list</i> for the
class <code>pie</code>.  The following <i>classes</i> are defined:

<pre class="lisp"> (defclass pie (apple cinnamon) ())

 (defclass apple (fruit) ())

 (defclass cinnamon (spice) ())

 (defclass fruit (food) ())

 (defclass spice (food) ())

 (defclass food () ())
</pre>
<p>The set S<sub>pie</sub>&nbsp;= <tt>{</tt><code>pie, apple, cinnamon, fruit, spice, food,
standard-object, t</code><tt>}</tt>. The set R&nbsp;= <tt>{</tt><code>(pie, apple),
(apple, cinnamon), (apple, fruit), (cinnamon, spice), 
(fruit, food), (spice, food), (food, standard-object), (standard-object,
t)</code><tt>}</tt>.

<p>The class <code>pie</code> is not preceded by anything, so it comes first;
the result so far is <code>(pie)</code>.  Remove <code>pie</code> from S and pairs
mentioning <code>pie</code> from R to get S&nbsp;= <tt>{</tt><code>apple, cinnamon,
fruit, spice, food, standard-object, t</code><tt>}</tt> and R&nbsp;=&nbsp;<tt>{</tt><code>(apple, cinnamon), (apple, fruit), (cinnamon, spice), (fruit,
food), (spice, food), (food, standard-object),
(standard-object, t)</code><tt>}</tt>.

<p>The class <code>apple</code> is not preceded by anything, so it is next; the
result is <code>(pie apple)</code>. Removing <code>apple</code> and the relevant
pairs results in S&nbsp;= <tt>{</tt><code>cinnamon, fruit, spice, food,
standard-object, t</code><tt>}</tt> and R&nbsp;= <tt>{</tt><code>(cinnamon, spice),
(fruit, food), (spice, food), (food, standard-object),
(standard-object, t)</code><tt>}</tt>.

<p>The classes <code>cinnamon</code> and <code>fruit</code> are not preceded by
anything, so the one with a direct <i>subclass</i> rightmost in the
<i>class precedence list</i> computed so far goes next.  The class <code>apple</code> is a
direct <i>subclass</i> of <code>fruit</code>, and the class <code>pie</code> is a direct
<i>subclass</i> of <code>cinnamon</code>.  Because <code>apple</code> appears to the right
of <code>pie</code> in the <i>class precedence list</i>,
<code>fruit</code> goes next, and the
result so far is <code>(pie apple fruit)</code>.  S&nbsp;= <tt>{</tt><code>cinnamon,
spice, food, standard-object, t</code><tt>}</tt>; R&nbsp;= <tt>{</tt><code>(cinnamon,
spice), (spice, food), (food, standard-object),
(standard-object, t)</code><tt>}</tt>.

<p>The class <code>cinnamon</code> is next, giving the result so far as <code>(pie apple fruit cinnamon)</code>.  At this point S&nbsp;= <tt>{</tt><code>spice,
food, standard-object, t</code><tt>}</tt>; R&nbsp;= <tt>{</tt><code>(spice, food), (food,
standard-object), (standard-object, t)</code><tt>}</tt>.

<p>The classes <code>spice</code>, <code>food</code>, <code>standard-object</code>, and
<code>t</code> are added in that order, and the <i>class precedence list</i>
is <code>(pie apple fruit cinnamon spice food standard-object t)</code>.

<p>It is possible to write a set of <i>class</i> definitions that cannot be
ordered.   For example:

<pre class="lisp"> (defclass new-class (fruit apple) ())

 (defclass apple (fruit) ())
</pre>
<p>The class <code>fruit</code> must precede <code>apple</code>
because the local ordering of <i>superclasses</i> must be preserved. 
The class <code>apple</code> must precede <code>fruit</code>
because a <i>class</i> always precedes its own <i>superclasses</i>. 
When this situation occurs, an error is signaled, as happens here
when the system tries to compute the <i>class precedence list</i>
of <code>new-class</code>.

<p>The following might appear to be a conflicting set of definitions:

<pre class="lisp"> (defclass pie (apple cinnamon) ())

 (defclass pastry (cinnamon apple) ())

 (defclass apple () ())

 (defclass cinnamon () ())
</pre>
<p>The <i>class precedence list</i> for <code>pie</code> is
<code>(pie apple cinnamon standard-object t)</code>.

<p>The <i>class precedence list</i> for <code>pastry</code> is
<code>(pastry cinnamon apple standard-object t)</code>.

<p>It is not a problem for <code>apple</code> to precede <code>cinnamon</code> in the
ordering of the <i>superclasses</i> of <code>pie</code> but not in the ordering for
<code>pastry</code>.  However, it is not possible to build a new <i>class</i> that
has both <code>pie</code> and <code>pastry</code> as <i>superclasses</i>.

</body>
<!-- Mirrored from mr.gy/ansi-common-lisp/Determining-the-Class-Precedence-List.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 10 Sep 2021 20:40:19 GMT -->
</html>

